#lang racket


(define matriz1 '((5 0 0 0 0 0 0 0 0)
                  (0 2 8 4 0 0 5 0 3)
                  (1 0 0 2 7 0 0 0 6)

                  (0 0 3 0 5 2 1 9 0)
                  (7 0 6 0 1 0 2 0 8)
                  (0 1 9 7 4 0 3 0 0)

                  (6 0 0 0 9 4 0 0 2)
                  (8 0 1 0 0 6 7 5 0)
                  (0 0 0 0 0 0 0 0 4)))

(define matriz3 '((0 0 4 0 3 0 0 6 0)
                  (1 6 0 0 0 2 0 3 0)
                  (9 0 2 8 0 6 4 5 0)

                  (0 0 0 0 6 0 9 1 0)
                  (0 0 0 0 0 0 0 0 0)
                  (0 1 8 0 5 0 0 0 0)

                  (0 2 6 1 0 5 3 0 4)
                  (0 7 0 6 0 0 0 8 2)
                  (0 4 0 0 2 0 6 0 0)))

(define matriz17'((3 0 8 0 0 0 0 0 0)
                  (0 0 0 0 4 0 5 0 7)
                  (6 7 0 0 5 8 0 1 9)

                  (1 8 0 0 0 0 0 0 0)
                  (7 9 0 8 2 3 0 4 5)
                  (0 0 0 0 0 0 0 9 3)

                  (4 6 0 7 8 0 0 3 1)
                  (2 0 9 0 1 0 0 0 0)
                  (0 0 0 0 0 0 4 0 6)))

(define matriz20'((8 0 0 4 6 0 0 0 0)
                  (0 0 0 0 1 0 0 0 9)
                  (0 7 0 3 0 8 6 0 0)

                  (2 0 0 0 0 0 0 9 0)
                  (3 8 0 0 7 0 0 2 1)
                  (0 5 0 0 0 0 0 0 8)

                  (0 0 4 5 0 6 0 1 0)
                  (5 0 0 4 0 0 0 0 0)
                  (0 0 0 0 9 3 0 0 6)))


(define listaAbiertos '())


#|******************************************************************************
  ***********************   METODOS COMPROBACION SUDOKU   **********************
  ******************************************************************************|#

#|=====================================================================
   Func: estaFila : list number number number -> boolean
   Obj: Devuelve #t cuando el numero esta en la fila y
        #f cuando no lo esta
  =====================================================================|#
(define (estaFila sudoku fila columna numero)
  (for/or ([c 9])
    (if (= c columna) ;si es la misma posicion no la compara
        #f
        (equal? (list-ref (list-ref sudoku fila) c) numero) ;compara la posicion para las demas posiciones
    )
  )
)


#|=====================================================================
   Func: estaColumna : list number number number -> boolean
   Obj: Devuelve #t cuando el numero esta en la columna y
        #f cuando no lo esta
  =====================================================================|#
(define (estaColumna sudoku columna fila numero)
  (for/or ([f 9])
    (if (= f fila) ; si es la misma posicion no la compara
        #f
        (equal? (list-ref (list-ref sudoku f) columna) numero) ;compara la posicion para las demas posiciones
    )
  )
)


#|===========================================================================
   Func: estaCuadrado list number number number number number -> boolean
   Obj: Devuelve #t cuando el numero esta en el cuadrado y
        #f cuando no lo esta
   Detalles: inicio y final son los valores que se iteran para recorrer el
             cuadrado, por otro lado fila y columna son los valores donde se
             encuentra el numero que se quiere comprobar y por tanto lo salta
  ===========================================================================|#
(define (estaCuadrado sudoku inicio final fila columna numero)
  (for*/or ([f (in-range inicio (+ 3 inicio))][c (in-range final (+ 3 final))])
    (if (and (= f fila) (= c columna)) ; si es la misma posicion no la compara
        #f
        (equal? (list-ref (list-ref sudoku f) c) numero) ;compara la posicion para las demas posiciones
    ) 
  )
)


#|===============================================================
   Func: estaPermitido : list number number number -> boolean
   Obj: Devulve #t si el numero puede ponerse en esa posicion
        y #f si no puede
  ===============================================================|#
(define (estaPermitido sudoku fila columna numero)
  (if (or (estaCuadrado sudoku (- fila (remainder fila 3)) (- columna (remainder columna 3)) fila columna numero) ;aqui iria el que ve si esta en el mismo cuadro
          (estaFila sudoku fila columna numero)
          (estaColumna sudoku columna fila numero)
      )
      #f #t)
)


#|===============================================================
   Func: sudokuInicioCorrecto? : list -> boolean
   Obj: Devulve #t si el sudoku es correcto y #f si no lo es sin contar las posiciones
        del sudoku con un 0 (comprueba al inicio del sudoku)
  ===============================================================|#
(define (sudokuInicioCorrecto? sudoku)
  (for*/and ([f 9][c 9])
    (cond
      ;si no es 0 mira si el numero esta repetido en su fila, columna o cuadrado
      [(not (equal? (list-ref (list-ref sudoku f) c) 0))
       (estaPermitido sudoku f c (list-ref (list-ref sudoku f) c))]
      ;si el numero es 0 pues directamente sera #t
      [else #t]
    )
  )
)


#|===============================================================
   Func: sudokuFinalCorrecto? : list -> boolean
   Obj: Devuelve #t si el sudoku es correcto y #f, teniendo en cuenta que
        no puede haber ninguna posicion con 0 (comprueba al final de sudoku)
  ===============================================================|#
(define (sudokuFinalCorrecto? sudoku)
  (for*/and ([f 9][c 9])
    (cond
      ;si el numero es igual a 0 no estará completo con lo cual #f
      [(equal? (list-ref (list-ref sudoku f) c) 0) #f]
      ;si no es 0 comprueba que el numero en esa posicion sea correcta
      [else (estaPermitido sudoku f c (list-ref (list-ref sudoku f) c))]
    )
  )
)



#|******************************************************************************
  *****************   METODOS QUE MANEJAN LISTA DE ABIERTOS   ******************
  ******************************************************************************|#

#|===============================================================
   Func: sucesores : list list number number list number string -> procedure
   Obj: Comprueba que sucesores puede haber en funcion de los posible valores
        permitidos en una posicion del sudoku, llamando finalmente a una funcion
        para insertar los valores en la lista de abiertos
   Detalles: contador es una varaible que toma valores entre 1-9 que son los
             posibles valores que puede haber en un sudoku
  ===============================================================|#
(define (sucesores listaAbiertos listaSucesores fila columna sudoku contador busqueda)
  (cond
    ;si ha probado todos los numero posibles llama a la funcion que introduce en anchura
    [(equal? contador 10)
     (cond
       [(equal? busqueda "profundidad") (abiertosProfundidad listaAbiertos listaSucesores fila columna sudoku)]
       [(equal? busqueda "anchura") (abiertosAnchura listaAbiertos listaSucesores fila columna sudoku)]
       [else "No se ha reconocido la busqueda"]
     )
    ]
    ;si no mira si esta permitido y si lo esta los mete en la lista de sucesores
    [else
     (if (estaPermitido sudoku fila columna contador)
         (sucesores listaAbiertos (append listaSucesores (list contador)) fila columna sudoku (add1 contador) busqueda)
         (sucesores listaAbiertos listaSucesores fila columna sudoku (add1 contador) busqueda)
     )]
  )
)


#|===============================================================
   Func: abiertosAnchura : lista lista number number list -> list
   Obj: Devuelve una lista de abierto en anchura con la información de los nodos
        abiertos (fila, columna, sudoku actual)
  ===============================================================|#
(define (abiertosAnchura abiertos sucesores fila columna sudoku)
  (cond
    ;si ya se han introducido todos los sucesores en abiertos pasa devuelve la lista
    [(null? sucesores)
     abiertos]
    ;si no llama a la funcion habiendo introducido en la lista el sudoku con el valor de sucesores añadido
    ;y sigue insertando los demas valores en la lista
    [else
     (abiertosAnchura (append abiertos (list (crearNodo '() fila columna (insertar sudoku '() fila columna (car sucesores) 0)))) (cdr sucesores) fila columna sudoku)]
  )
)


#|===============================================================
   Func: anchura : lista lista number number list -> list
   Obj: Devuelve una lista de abierto en anchura con la información de los nodos
        abiertos (fila, columna, sudoku actual)
  ===============================================================|#
(define (abiertosProfundidad abiertos sucesores fila columna sudoku)
  (cond
    ;si ya se han introducido todos los sucesores devuelve la lista
    [(null? sucesores)
     abiertos]
    ;si quedan valores por introducir instroducimos los valor en una pila tipo LIFO
    [else
     (let ((reverseSucesores (reverse sucesores)))
       (abiertosProfundidad (append (list (crearNodo '() fila columna (insertar sudoku '() fila columna (car reverseSucesores) 0))) abiertos) (reverse (cdr reverseSucesores)) fila columna sudoku))]
     ;creamos una variable que es la lista de sucesores dada la vuelta y llamamos a la funcion con la lista de abiertos
     ;la lista de sucesores ( 1 2 3 ) ( 7 8 ) pues seria (3 2 1) + car(8 7) que es (3 2 1) + (8) (3 2 1 8), finalmente haciendo reverse (8 3 2 1)
     ;quedando la lista de abiertos asi (7 8 1 2 3)
  )
)


#|===============================================================
   Func: crearNodo : list number number number -> list
   Obj: Devuelve una lista con la información del nuevo nodo, introduciendo de uno en uno
        y de forma recusiva los valores (fila, columna, valor)
  ===============================================================|#
(define (crearNodo lista coord1 coord2 sudoku)
  (cond
        [(= (length lista) 0) (crearNodo (append lista (list coord1)) coord1 coord2 sudoku)]
        [(= (length lista) 1) (crearNodo (append lista (list coord2)) coord1 coord2 sudoku)]
        [(= (length lista) 2) (crearNodo (append lista (list sudoku)) coord1 coord2 sudoku)]
        [(= (length lista) 3) lista]))


#|===============================================================
   Func: sacar : list -> list 
   Obj: Devuelve una lista correspondiente al primer nodo de la lista de abiertos
  ===============================================================|#
(define (sacar lista)
  (list-ref lista 0))


#|===============================================================
   Func: eliminar : list -> list 
   Obj: Devuelve la lista de nodos abiertos eliminando el primer elemento
  ===============================================================|#
(define (eliminar lista)
  (cdr lista))



#|******************************************************************************
  *********************   METODOS QUE MANEJAN EL SUDOKU   **********************
  ******************************************************************************|#

#|===============================================================
   Func: insertar : list list number number number -> list
   Obj: Devuelve la lista del sudoku después de insertar el nodo
  ===============================================================|#
(define (insertar lista lista2 fila columna numero contador)
  (cond [(= contador 9) lista2]
        ;si esta en la posicion que se quiere cambiar se cambia
        [(= fila contador) (insertar lista (append lista2 (list (introducirNumero (list-ref lista contador) '() columna numero))) fila columna numero (+ contador 1))]
        ;si no esta en la posicion que se quiere cambiar no hace nada
        [else (insertar lista (append lista2 (list (list-ref lista contador))) fila columna numero (+ contador 1))]))


#|===============================================================
   Func: crearNodo : list list number number -> list
   Obj: Devuelve una lista con el elemento cambiado en la posicion indicada
  ===============================================================|#
(define (introducirNumero lista lista2 posicion numero)
    (cond [(= (length lista) 0) lista2]
          [(= posicion 0) (introducirNumero (cdr lista) (append lista2 (list numero)) (- posicion 1) numero)]
          [else (introducirNumero (cdr lista) (append lista2 (list (car lista))) (- posicion 1) numero)]))




#|******************************************************************************
  *********************   METODOS RESOLUCION DE SUDOKU   ***********************
  ******************************************************************************|#

#|===============================================================
   Func: resolverSudoku : list number number list -> procedure
   Obj: Si el sudoku se puede resolver llama al metodo que resulve el
        sudoku si no se puede resolver printea que no se puede
  ===============================================================|#
(define (resolverSudoku sudoku filaC columnaC listaAbiertos busqueda)
  (cond
    [(sudokuInicioCorrecto? sudoku) (solucionSudoku sudoku filaC columnaC listaAbiertos busqueda)]
    [else (display "No se puede resolver") (newline)]
  )
)


#|===============================================================
   Func: solucionSudoku : list number number list -> procedure (printSudoku)
   Obj: Metodo donde se desarrolla la logica para la resolucion del sudoku
  ===============================================================|#
(define (solucionSudoku sudoku filaC columnaC listaAbiertos busqueda)
  (cond
    ;si el sudoku es correcto lo printea
    [(sudokuFinalCorrecto? sudoku)
     (printSudoku sudoku)
    ]
    ;comprueba si el sudoku ha sido totalmente comprobado
    [(equal? filaC 9)
     (cond
       ;no es completo y no hay abiertos
       [(null? listaAbiertos)
        (printf "No se puede seguir")]
       ;si no es completo pero no esta vacia la lista de abiertos se sigue comprobando
       [else
        (let ((abiertos (sucesores listaAbiertos '() filaC columnaC sudoku 1 busqueda)))
              (printSudoku sudoku)(solucionSudoku (list-ref (sacar abiertos) 2) (list-ref (sacar abiertos) 0) (add1 (list-ref (sacar abiertos) 1)) (eliminar abiertos) busqueda)
        )
      ]
     )
    ]
    ;comprueba si ha llegado al final de una linea y va a la siguiente fila
    [(equal? columnaC 9)
     (solucionSudoku sudoku (add1 filaC) (- columnaC 9) listaAbiertos busqueda)]
    ;si es cualquier otra posición que no sea final de fila o final de sudoku
    [else
     (if (equal? (list-ref (list-ref sudoku filaC) columnaC) 0)
            ;si es 0 "guardamos" en una variable la nueva lista de abiertos y llamamos a la funcion con la fila, columna y sudoku
            ;del primer nodo de la lista de abiertos
            (let ((abiertos (sucesores listaAbiertos '() filaC columnaC sudoku 1 busqueda)))
              (solucionSudoku (list-ref (sacar abiertos) 2) (list-ref (sacar abiertos) 0) (add1 (list-ref (sacar abiertos) 1)) (eliminar abiertos) busqueda)
            )
            ;si no es 0 seguimos iterado el sudoku
            (solucionSudoku sudoku filaC (add1 columnaC) listaAbiertos busqueda)
      )
    ]
  )
)
     
     ;!!!!!!!!!!!!!!!¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
     ;CREO QUE LO QUE ESTA COMENTADO ABAJO NO HACE FALTA, YA QUE TE DA IGUAL QUE ESTE O NO LA LISTA DE ABIERTOS VACIA PORQUE LA LLENAS ANTES DE LLAMAR
     ;A LA FUNCION DE FORMA RECURSIVA
     ;!!!!!!!!!!!!!!!¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
     #|(cond
       ;si no hay ningun abierto en la lista entonces, no podremos coger ningun valor de ella
       [(null? listaAbiertos)
        ;si el numero de la posicion NO es 0 llamamos a la funcion igual, pero si no es 0 llamamos a la funcion con el sudoku que se genera
        ;en el primer nodo mas la nueva lista de abierto sin el primer nodo, en los dos casos iteramos el contador de columna
        (if (equal? (list-ref (list-ref sudoku filaC) columnaC) 0)
            ;si es 0 el numero de la posicion indicada
            (let ((abiertos (sucesores listaAbiertos '() filaC columnaC sudoku 1 busqueda)))
              (solucionSudoku (list-ref (sacar abiertos) 2) filaC (add1 columnaC) (eliminar abiertos) busqueda)
            )
              (solucionSudoku sudoku filaC (add1 columnaC) listaAbiertos busqueda)
         )
       ]
       ;si la lista de abiertos tiene cosas dentro, comprobamos si el numero de la posicion indicada es 0
       [else
        (if (equal? (list-ref (list-ref sudoku filaC) columnaC) 0)
            ;si es 0 "guardamos" en una variable la nueva lista de abiertos y llamamos a la funcion con la fila, columna y sudoku
            ;del primer nodo de la lista de abiertos
            (let ((abiertos (sucesores listaAbiertos '() filaC columnaC sudoku 1 busqueda)))
              (solucionSudoku (list-ref (sacar abiertos) 2) (list-ref (sacar abiertos) 0) (add1 (list-ref (sacar abiertos) 1)) (eliminar abiertos) busqueda)
            )
            ;si no es 0 seguimos iterado el sudoku
            (solucionSudoku sudoku filaC (add1 columnaC) listaAbiertos busqueda)
         )
       ]
     )|#


#|===============================================================
   Func: printSudoku : list number number list -> 
   Obj: Método que muestra por pantalla, con un formato adecuado el sudoku que se pase
        como parámetro
  ===============================================================|#
(define (printSudoku sudoku)
  (for ([i 9])
    (cond
      ;si la siguiente fila a printear es el principio de una celda
      ;printeamos la separacion
      [(equal? (remainder i 3) 0)
       (printf "+---------+---------+---------+\n")]
    )
    (for ([j 9])
      (cond
        ;si la siguiente posicion es el principio de una celda
        ;printeamos la separacion interna
        [(equal? (remainder j 3) 0)
         (printf "|")]
      )

      (printf " ~a " (list-ref (list-ref sudoku i) j))
    )

    (printf "|\n")
  )
  (printf "+---------+---------+---------+\n")
)

(printf "Prueba función estaFila\n")

(define (pruebaEstaFila sudoku fila columna valor retorno)
  (equal? retorno (estaFila sudoku fila columna valor)))

(pruebaEstaFila matriz1 1 0 2 #t)
(pruebaEstaFila matriz1 1 0 6 #t)

(printf "Prueba función estaColumna\n")
(printf "Prueba función estaCuadrado\n")
(printf "Prueba función estaPermitido\n")
(printf "Prueba función sudokuInicioCorrecto?\n")
(printf "Prueba función sudokuFinalCorrecto?\n")
(printf "Prueba función sucesores\n")
(printf "Prueba función crearNodo\n")
(printf "Prueba función insertar\n")

(resolverSudoku matriz1 0 0 listaAbiertos "anchura")
(resolverSudoku matriz1 0 0 listaAbiertos "profundidad")
(resolverSudoku matriz3 0 0 listaAbiertos "anchura")
(resolverSudoku matriz3 0 0 listaAbiertos "profundidad")
(resolverSudoku matriz20 0 0 listaAbiertos "anchura")
(resolverSudoku matriz20 0 0 listaAbiertos "profundidad")
(resolverSudoku matriz17 0 0 listaAbiertos "anchura")
(resolverSudoku matriz17 0 0 listaAbiertos "profundidad")

